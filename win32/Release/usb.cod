; Listing generated by Microsoft (R) Optimizing Compiler Version 19.30.30705.0 

	TITLE	C:\Users\Beat\git_projekte\dtb\psi46test\win32\Release\usb.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
PUBLIC	??0CRpcError@@QAE@W4errorId@0@@Z		; CRpcError::CRpcError
PUBLIC	?FillBuffer@CUSB@@AAE_NK@Z			; CUSB::FillBuffer
PUBLIC	?GetErrorMsg@CUSB@@SAPBDH@Z			; CUSB::GetErrorMsg
PUBLIC	?EnumFirst@CUSB@@QAE_NAAI@Z			; CUSB::EnumFirst
PUBLIC	?EnumNext@CUSB@@QAE_NQAD@Z			; CUSB::EnumNext
PUBLIC	?Enum@CUSB@@QAE_NQADI@Z				; CUSB::Enum
PUBLIC	?Open@CUSB@@QAE_NQAD@Z				; CUSB::Open
PUBLIC	?Close@CUSB@@UAEXXZ				; CUSB::Close
PUBLIC	?Write@CUSB@@UAEXPBXI@Z				; CUSB::Write
PUBLIC	?Flush@CUSB@@UAEXXZ				; CUSB::Flush
PUBLIC	?Clear@CUSB@@UAEXXZ				; CUSB::Clear
PUBLIC	?Read@CUSB@@UAEXPAXI@Z				; CUSB::Read
PUBLIC	__TI1?AVCRpcError@@
PUBLIC	__CTA1?AVCRpcError@@
PUBLIC	??_R0?AVCRpcError@@@8				; CRpcError `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVCRpcError@@@88
PUBLIC	??_C@_02MFDMBIJM@ok@				; `string'
PUBLIC	??_C@_0P@MNPFLEBL@invalid?5handle@		; `string'
PUBLIC	??_C@_0BB@IHDJLKMG@device?5not?5found@		; `string'
PUBLIC	??_C@_0BC@HFCLPILE@device?5not?5opened@		; `string'
PUBLIC	??_C@_08GLNPIFBN@io?5error@			; `string'
PUBLIC	??_C@_0BG@JGELIADJ@insufficient?5resource@	; `string'
PUBLIC	??_C@_0BC@GMEMBNHN@invalid?5parameter@		; `string'
PUBLIC	??_C@_0BC@JEMNCEK@invalid?5baud?5rate@		; `string'
PUBLIC	??_C@_0BM@FOIECFGC@device?5not?5opened?5for?5erase@ ; `string'
PUBLIC	??_C@_0BM@NAGBLIJI@device?5not?5opened?5for?5write@ ; `string'
PUBLIC	??_C@_0BH@CBBLICLP@failed?5to?5write?5device@	; `string'
PUBLIC	??_C@_0BD@HPOCEFDP@eeprom?5read?5failed@	; `string'
PUBLIC	??_C@_0BE@KJGDCNBK@eeprom?5write?5failed@	; `string'
PUBLIC	??_C@_0BE@CFCHMELH@eeprom?5erase?5failed@	; `string'
PUBLIC	??_C@_0BD@JKEPJBHF@eeprom?5not?5present@	; `string'
PUBLIC	??_C@_0BG@JMCJFOE@eeprom?5not?5programmed@	; `string'
PUBLIC	??_C@_0N@LBHEEELJ@invalid?5args@		; `string'
PUBLIC	??_C@_0O@NHEDABJP@not?5supported@		; `string'
PUBLIC	??_C@_0M@CBIEBGLO@other?5error@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error@		; `string'
EXTRN	__imp__FT_OpenEx@12:PROC
EXTRN	__imp__FT_ListDevices@12:PROC
EXTRN	__imp__FT_Close@4:PROC
EXTRN	__imp__FT_Read@16:PROC
EXTRN	__imp__FT_Write@16:PROC
EXTRN	__imp__FT_Purge@8:PROC
EXTRN	__imp__FT_SetTimeouts@12:PROC
EXTRN	__imp__FT_GetQueueStatus@8:PROC
EXTRN	__imp__FT_SetBitMode@12:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CBIEBGLO@other?5error@
CONST	SEGMENT
??_C@_0M@CBIEBGLO@other?5error@ DB 'other error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@NHEDABJP@not?5supported@
CONST	SEGMENT
??_C@_0O@NHEDABJP@not?5supported@ DB 'not supported', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LBHEEELJ@invalid?5args@
CONST	SEGMENT
??_C@_0N@LBHEEELJ@invalid?5args@ DB 'invalid args', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JMCJFOE@eeprom?5not?5programmed@
CONST	SEGMENT
??_C@_0BG@JMCJFOE@eeprom?5not?5programmed@ DB 'eeprom not programmed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@JKEPJBHF@eeprom?5not?5present@
CONST	SEGMENT
??_C@_0BD@JKEPJBHF@eeprom?5not?5present@ DB 'eeprom not present', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CFCHMELH@eeprom?5erase?5failed@
CONST	SEGMENT
??_C@_0BE@CFCHMELH@eeprom?5erase?5failed@ DB 'eeprom erase failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KJGDCNBK@eeprom?5write?5failed@
CONST	SEGMENT
??_C@_0BE@KJGDCNBK@eeprom?5write?5failed@ DB 'eeprom write failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HPOCEFDP@eeprom?5read?5failed@
CONST	SEGMENT
??_C@_0BD@HPOCEFDP@eeprom?5read?5failed@ DB 'eeprom read failed', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CBBLICLP@failed?5to?5write?5device@
CONST	SEGMENT
??_C@_0BH@CBBLICLP@failed?5to?5write?5device@ DB 'failed to write device', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NAGBLIJI@device?5not?5opened?5for?5write@
CONST	SEGMENT
??_C@_0BM@NAGBLIJI@device?5not?5opened?5for?5write@ DB 'device not opened'
	DB	' for write', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FOIECFGC@device?5not?5opened?5for?5erase@
CONST	SEGMENT
??_C@_0BM@FOIECFGC@device?5not?5opened?5for?5erase@ DB 'device not opened'
	DB	' for erase', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JEMNCEK@invalid?5baud?5rate@
CONST	SEGMENT
??_C@_0BC@JEMNCEK@invalid?5baud?5rate@ DB 'invalid baud rate', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GMEMBNHN@invalid?5parameter@
CONST	SEGMENT
??_C@_0BC@GMEMBNHN@invalid?5parameter@ DB 'invalid parameter', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JGELIADJ@insufficient?5resource@
CONST	SEGMENT
??_C@_0BG@JGELIADJ@insufficient?5resource@ DB 'insufficient resource', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08GLNPIFBN@io?5error@
CONST	SEGMENT
??_C@_08GLNPIFBN@io?5error@ DB 'io error', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@HFCLPILE@device?5not?5opened@
CONST	SEGMENT
??_C@_0BC@HFCLPILE@device?5not?5opened@ DB 'device not opened', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@IHDJLKMG@device?5not?5found@
CONST	SEGMENT
??_C@_0BB@IHDJLKMG@device?5not?5found@ DB 'device not found', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@MNPFLEBL@invalid?5handle@
CONST	SEGMENT
??_C@_0P@MNPFLEBL@invalid?5handle@ DB 'invalid handle', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02MFDMBIJM@ok@
CONST	SEGMENT
??_C@_02MFDMBIJM@ok@ DB 'ok', 00H			; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVCRpcError@@@88
xdata$x	SEGMENT
__CT??_R0?AVCRpcError@@@88 DD 00H
	DD	FLAT:??_R0?AVCRpcError@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	08H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0?AVCRpcError@@@8
data$r	SEGMENT
??_R0?AVCRpcError@@@8 DD FLAT:??_7type_info@@6B@	; CRpcError `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVCRpcError@@', 00H
data$r	ENDS
;	COMDAT __CTA1?AVCRpcError@@
xdata$x	SEGMENT
__CTA1?AVCRpcError@@ DD 01H
	DD	FLAT:__CT??_R0?AVCRpcError@@@88
xdata$x	ENDS
;	COMDAT __TI1?AVCRpcError@@
xdata$x	SEGMENT
__TI1?AVCRpcError@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1?AVCRpcError@@
xdata$x	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Beat\git_projekte\dtb\psi46test\usb.cpp
;	COMDAT ?Read@CUSB@@UAEXPAXI@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_buffer$ = 8						; size = 4
_bytesToRead$ = 12					; size = 4
?Read@CUSB@@UAEXPAXI@Z PROC				; CUSB::Read, COMDAT
; _this$ = ecx

; 243  : { PROFILING

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi

; 244  : 	if (!isUSB_open) throw CRpcError(CRpcError::READ_ERROR);

  0000a	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0000e	0f 84 84 00 00
	00		 je	 $LN16@Read

; 245  : 
; 246  : 	DWORD i;
; 247  : 
; 248  : 	for (i=0; i<bytesToRead; i++)

  00014	8b 4d 0c	 mov	 ecx, DWORD PTR _bytesToRead$[ebp]
  00017	33 ff		 xor	 edi, edi
  00019	85 c9		 test	 ecx, ecx
  0001b	74 6f		 je	 SHORT $LN3@Read
  0001d	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  00020	53		 push	 ebx
$LL4@Read:

; 249  : 	{
; 250  : 		if (m_posR<m_sizeR)

  00021	8b 86 1c 04 00
	00		 mov	 eax, DWORD PTR [esi+1052]
  00027	3b 86 20 04 00
	00		 cmp	 eax, DWORD PTR [esi+1056]
  0002d	73 0c		 jae	 SHORT $LN6@Read

; 251  : 			((unsigned char*)buffer)[i] = m_bufferR[m_posR++];

  0002f	8a 84 30 24 04
	00 00		 mov	 al, BYTE PTR [eax+esi+1060]
  00036	88 04 17	 mov	 BYTE PTR [edi+edx], al
  00039	eb 45		 jmp	 SHORT $LN21@Read
$LN6@Read:

; 252  : 
; 253  : 		else
; 254  : 		{
; 255  : 			DWORD n = bytesToRead-i;

  0003b	8b d9		 mov	 ebx, ecx

; 256  : 			if (n>USBREADBUFFERSIZE) n = USBREADBUFFERSIZE;

  0003d	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  00042	2b df		 sub	 ebx, edi

; 257  : 
; 258  : 			if (!FillBuffer(n)) throw CRpcError(CRpcError::READ_ERROR);

  00044	8b ce		 mov	 ecx, esi
  00046	81 fb 00 10 00
	00		 cmp	 ebx, 4096		; 00001000H
  0004c	0f 47 d8	 cmova	 ebx, eax
  0004f	53		 push	 ebx
  00050	e8 00 00 00 00	 call	 ?FillBuffer@CUSB@@AAE_NK@Z ; CUSB::FillBuffer
  00055	84 c0		 test	 al, al
  00057	74 3f		 je	 SHORT $LN16@Read

; 259  : 			if (m_sizeR < n) throw CRpcError(CRpcError::READ_ERROR);

  00059	8b 86 20 04 00
	00		 mov	 eax, DWORD PTR [esi+1056]
  0005f	3b c3		 cmp	 eax, ebx
  00061	72 35		 jb	 SHORT $LN16@Read

; 260  : 
; 261  : 			if (m_posR<m_sizeR)

  00063	8b 8e 1c 04 00
	00		 mov	 ecx, DWORD PTR [esi+1052]
  00069	3b c8		 cmp	 ecx, eax
  0006b	73 27		 jae	 SHORT $LN11@Read

; 262  : 				((unsigned char*)buffer)[i] = m_bufferR[m_posR++];

  0006d	8a 84 31 24 04
	00 00		 mov	 al, BYTE PTR [ecx+esi+1060]
  00074	8b 4d 08	 mov	 ecx, DWORD PTR _buffer$[ebp]
  00077	8b 55 08	 mov	 edx, DWORD PTR _buffer$[ebp]
  0007a	88 04 0f	 mov	 BYTE PTR [edi+ecx], al
  0007d	8b 4d 0c	 mov	 ecx, DWORD PTR _bytesToRead$[ebp]
$LN21@Read:

; 245  : 
; 246  : 	DWORD i;
; 247  : 
; 248  : 	for (i=0; i<bytesToRead; i++)

  00080	ff 86 1c 04 00
	00		 inc	 DWORD PTR [esi+1052]
  00086	47		 inc	 edi
  00087	3b f9		 cmp	 edi, ecx
  00089	72 96		 jb	 SHORT $LL4@Read

; 259  : 			if (m_sizeR < n) throw CRpcError(CRpcError::READ_ERROR);

  0008b	5b		 pop	 ebx
$LN3@Read:
  0008c	5f		 pop	 edi

; 266  : 			}
; 267  : 		}
; 268  : 	}
; 269  : }

  0008d	5e		 pop	 esi
  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 08 00	 ret	 8
$LN11@Read:

; 263  : 			else
; 264  : 			{   // timeout (bytesRead < bytesToRead)
; 265  : 				throw CRpcError(CRpcError::READ_TIMEOUT);

  00094	6a 04		 push	 4
  00096	eb 02		 jmp	 SHORT $LN22@Read
$LN16@Read:

; 266  : 			}
; 267  : 		}
; 268  : 	}
; 269  : }

  00098	6a 03		 push	 3
$LN22@Read:
  0009a	8d 4d f8	 lea	 ecx, DWORD PTR $T1[ebp]
  0009d	e8 00 00 00 00	 call	 ??0CRpcError@@QAE@W4errorId@0@@Z ; CRpcError::CRpcError
  000a2	68 00 00 00 00	 push	 OFFSET __TI1?AVCRpcError@@
  000a7	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN20@Read:
  000b0	cc		 int	 3
?Read@CUSB@@UAEXPAXI@Z ENDP				; CUSB::Read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Beat\git_projekte\dtb\psi46test\usb.cpp
;	COMDAT ?Clear@CUSB@@UAEXXZ
_TEXT	SEGMENT
?Clear@CUSB@@UAEXXZ PROC				; CUSB::Clear, COMDAT
; _this$ = ecx

; 273  : { PROFILING

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 274  : 	if (!isUSB_open) return;

  00003	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00007	74 29		 je	 SHORT $LN1@Clear

; 275  : 
; 276  : 	ftStatus = FT_Purge(ftHandle, FT_PURGE_RX|FT_PURGE_TX);

  00009	6a 03		 push	 3
  0000b	ff 76 08	 push	 DWORD PTR [esi+8]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_Purge@8
  00014	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 277  : 	m_posR = m_sizeR = 0;

  00017	c7 86 20 04 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1056], 0
  00021	c7 86 1c 04 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1052], 0

; 278  : 	m_posW = 0;

  0002b	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
$LN1@Clear:

; 279  : }

  00032	5e		 pop	 esi
  00033	c3		 ret	 0
?Clear@CUSB@@UAEXXZ ENDP				; CUSB::Clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Beat\git_projekte\dtb\psi46test\usb.cpp
;	COMDAT ?Flush@CUSB@@UAEXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 8
_bytesWritten$ = -4					; size = 4
?Flush@CUSB@@UAEXXZ PROC				; CUSB::Flush, COMDAT
; _this$ = ecx

; 201  : { PROFILING

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	57		 push	 edi

; 202  : 	DWORD bytesWritten;
; 203  : 	DWORD bytesToWrite = m_posW;
; 204  : 	m_posW = 0;
; 205  : 
; 206  : 	if (!isUSB_open) throw CRpcError(CRpcError::WRITE_ERROR);

  0000a	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0000e	8b 7e 18	 mov	 edi, DWORD PTR [esi+24]
  00011	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  00018	74 31		 je	 SHORT $LN8@Flush

; 207  : 
; 208  : 	if (!bytesToWrite) return;

  0001a	85 ff		 test	 edi, edi
  0001c	74 27		 je	 SHORT $LN5@Flush

; 209  : 
; 210  : 	ftStatus = FT_Write(ftHandle, m_bufferW, bytesToWrite, &bytesWritten);

  0001e	8d 45 fc	 lea	 eax, DWORD PTR _bytesWritten$[ebp]
  00021	50		 push	 eax
  00022	57		 push	 edi
  00023	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  00026	50		 push	 eax
  00027	ff 76 08	 push	 DWORD PTR [esi+8]
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_Write@16
  00030	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 211  : 
; 212  : 	if (ftStatus != FT_OK) throw CRpcError(CRpcError::WRITE_ERROR);

  00033	85 c0		 test	 eax, eax
  00035	75 14		 jne	 SHORT $LN8@Flush

; 213  : 	if (bytesWritten != bytesToWrite) { ftStatus = FT_IO_ERROR; throw CRpcError(CRpcError::WRITE_ERROR); }

  00037	39 7d fc	 cmp	 DWORD PTR _bytesWritten$[ebp], edi
  0003a	74 09		 je	 SHORT $LN5@Flush
  0003c	c7 46 0c 04 00
	00 00		 mov	 DWORD PTR [esi+12], 4
  00043	eb 06		 jmp	 SHORT $LN8@Flush
$LN5@Flush:
  00045	5f		 pop	 edi

; 214  : }

  00046	5e		 pop	 esi
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
$LN8@Flush:
  0004b	6a 02		 push	 2
  0004d	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00050	e8 00 00 00 00	 call	 ??0CRpcError@@QAE@W4errorId@0@@Z ; CRpcError::CRpcError
  00055	68 00 00 00 00	 push	 OFFSET __TI1?AVCRpcError@@
  0005a	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN7@Flush:
  00063	cc		 int	 3
?Flush@CUSB@@UAEXXZ ENDP				; CUSB::Flush
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Beat\git_projekte\dtb\psi46test\usb.cpp
;	COMDAT ?Write@CUSB@@UAEXPBXI@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
_buffer$ = 8						; size = 4
_bytesToWrite$ = 12					; size = 4
?Write@CUSB@@UAEXPBXI@Z PROC				; CUSB::Write, COMDAT
; _this$ = ecx

; 188  : { PROFILING

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	57		 push	 edi

; 189  : 	if (!isUSB_open) throw CRpcError(CRpcError::WRITE_ERROR);

  0000b	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0000f	74 3d		 je	 SHORT $LN14@Write

; 190  : 
; 191  : 	DWORD k=0;
; 192  : 	for (k=0; k < bytesToWrite; k++)

  00011	8b 5d 0c	 mov	 ebx, DWORD PTR _bytesToWrite$[ebp]
  00014	33 ff		 xor	 edi, edi
  00016	85 db		 test	 ebx, ebx
  00018	74 2b		 je	 SHORT $LN3@Write
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL4@Write:

; 193  : 	{
; 194  : 		if (m_posW >= USBWRITEBUFFERSIZE) Flush();

  00020	81 7e 18 00 04
	00 00		 cmp	 DWORD PTR [esi+24], 1024 ; 00000400H
  00027	72 07		 jb	 SHORT $LN6@Write
  00029	8b 06		 mov	 eax, DWORD PTR [esi]
  0002b	8b ce		 mov	 ecx, esi
  0002d	ff 50 08	 call	 DWORD PTR [eax+8]
$LN6@Write:

; 195  : 		m_bufferW[m_posW++] = ((unsigned char*)buffer)[k];

  00030	8b 45 08	 mov	 eax, DWORD PTR _buffer$[ebp]
  00033	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00036	8a 04 07	 mov	 al, BYTE PTR [edi+eax]
  00039	47		 inc	 edi
  0003a	88 44 31 1c	 mov	 BYTE PTR [ecx+esi+28], al
  0003e	ff 46 18	 inc	 DWORD PTR [esi+24]
  00041	3b fb		 cmp	 edi, ebx
  00043	72 db		 jb	 SHORT $LL4@Write
$LN3@Write:
  00045	5f		 pop	 edi

; 196  : 	}
; 197  : }

  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 08 00	 ret	 8
$LN14@Write:

; 189  : 	if (!isUSB_open) throw CRpcError(CRpcError::WRITE_ERROR);

  0004e	6a 02		 push	 2
  00050	8d 4d f8	 lea	 ecx, DWORD PTR $T1[ebp]
  00053	e8 00 00 00 00	 call	 ??0CRpcError@@QAE@W4errorId@0@@Z ; CRpcError::CRpcError
  00058	68 00 00 00 00	 push	 OFFSET __TI1?AVCRpcError@@
  0005d	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN12@Write:
  00066	cc		 int	 3
?Write@CUSB@@UAEXPBXI@Z ENDP				; CUSB::Write
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Beat\git_projekte\dtb\psi46test\usb.cpp
;	COMDAT ?Close@CUSB@@UAEXXZ
_TEXT	SEGMENT
?Close@CUSB@@UAEXXZ PROC				; CUSB::Close, COMDAT
; _this$ = ecx

; 180  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 181  : 	if (!isUSB_open) return;

  00003	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  00007	74 0d		 je	 SHORT $LN1@Close

; 182  : 	FT_Close(ftHandle);

  00009	ff 76 08	 push	 DWORD PTR [esi+8]
  0000c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_Close@4

; 183  : 	isUSB_open = 0;

  00012	c6 46 04 00	 mov	 BYTE PTR [esi+4], 0
$LN1@Close:

; 184  : }

  00016	5e		 pop	 esi
  00017	c3		 ret	 0
?Close@CUSB@@UAEXXZ ENDP				; CUSB::Close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Beat\git_projekte\dtb\psi46test\usb.cpp
;	COMDAT ?Open@CUSB@@QAE_NQAD@Z
_TEXT	SEGMENT
_serialNumber$ = 8					; size = 4
?Open@CUSB@@QAE_NQAD@Z PROC				; CUSB::Open, COMDAT
; _this$ = ecx

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 88   : 	if (isUSB_open) { ftStatus = FT_DEVICE_NOT_OPENED; return false; }

  00006	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0000a	74 0e		 je	 SHORT $LN2@Open
  0000c	c7 46 0c 03 00
	00 00		 mov	 DWORD PTR [esi+12], 3
  00013	32 c0		 xor	 al, al
  00015	5e		 pop	 esi

; 176  : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@Open:
  0001a	57		 push	 edi

; 89   : 
; 90   : 	m_posR = m_sizeR = m_posW = 0;
; 91   : 
; 92   : 	ftStatus = FT_OpenEx(serialNumber, FT_OPEN_BY_SERIAL_NUMBER, &ftHandle);

  0001b	8d 7e 08	 lea	 edi, DWORD PTR [esi+8]
  0001e	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  00025	57		 push	 edi
  00026	6a 01		 push	 1
  00028	ff 75 08	 push	 DWORD PTR _serialNumber$[ebp]
  0002b	c7 86 20 04 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1056], 0
  00035	c7 86 1c 04 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1052], 0
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_OpenEx@12
  00045	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 93   : 
; 94   : 	if (ftStatus != FT_OK)

  00048	85 c0		 test	 eax, eax
  0004a	75 34		 jne	 SHORT $LN6@Open

; 95   : #ifdef _WIN32
; 96   : 		return false;
; 97   : #else
; 98   : 	{
; 99   :         /* maybe the ftdi_sio and usbserial kernel modules are attached to the device */
; 100  :         /* try to detach them using the libusb library directly */
; 101  : 
; 102  :         /* prepare libusb structures */
; 103  :         libusb_device ** list;
; 104  :         libusb_device_handle *handle;
; 105  :         struct libusb_device_descriptor descriptor;
; 106  : 
; 107  :         /* initialise libusb and get device list*/
; 108  :         libusb_init(NULL);
; 109  :         ssize_t ndevices = libusb_get_device_list(NULL, &list);
; 110  :         if( ndevices < 0)
; 111  :           return false;
; 112  : 
; 113  :         char serial [20];
; 114  : 
; 115  :         bool found = false;
; 116  : 
; 117  :         /* loop over all USB devices */
; 118  :         for( int dev = 0; dev < ndevices; dev++) {
; 119  :             /* get the device descriptor */
; 120  :             int ok = libusb_get_device_descriptor(list[dev], &descriptor);
; 121  :             if( ok != 0)
; 122  :                 continue;
; 123  :             /* we're only interested in devices with one vendor and two possible product ID */
; 124  :             if( descriptor.idVendor != 0x0403 && (descriptor.idProduct != 0x6001 || descriptor.idProduct != 0x6014))
; 125  :                 continue;
; 126  : 
; 127  :             /* open the device */
; 128  :             ok = libusb_open(list[dev], &handle);
; 129  :             if( ok != 0)
; 130  :                     continue;
; 131  :             /* Read the serial number from the device */
; 132  :             ok = libusb_get_string_descriptor_ascii(handle, descriptor.iSerialNumber, (unsigned char *) serial, 20);
; 133  :             if( ok < 0)
; 134  :                 continue;
; 135  : 
; 136  :             /* Check the device serial number */
; 137  :             if( strcmp(serialNumber, serial) == 0) {
; 138  :                 /* that's our device */
; 139  :                 found = true;
; 140  : 
; 141  :                 /* Detach the kernel module from the device */
; 142  :                 ok = libusb_detach_kernel_driver(handle, 0);
; 143  :                 if( ok == 0)
; 144  :                     printf("Detached kernel driver from selected testboard.\n");
; 145  :                 else
; 146  :                     printf("Unable to detach kernel driver from selected testboard.\n");
; 147  :                 break;
; 148  :             }
; 149  : 
; 150  :             libusb_close(handle);
; 151  :         }
; 152  : 
; 153  :         libusb_free_device_list(list, 1);
; 154  : 
; 155  :         /* if the device was not found in the previous loop, don't try again */
; 156  :         if( !found)
; 157  :             return false;
; 158  : 
; 159  :         /* try to re-open with the detached device */
; 160  :         ftStatus = FT_OpenEx(serialNumber, FT_OPEN_BY_SERIAL_NUMBER, &ftHandle);
; 161  :         if( ftStatus != FT_OK)
; 162  :             return false;
; 163  :     }
; 164  : #endif
; 165  : 
; 166  : 
; 167  : 	ftStatus = FT_SetBitMode(ftHandle, 0xFF, 0x40);

  0004c	6a 40		 push	 64			; 00000040H
  0004e	68 ff 00 00 00	 push	 255			; 000000ffH
  00053	ff 37		 push	 DWORD PTR [edi]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_SetBitMode@12
  0005b	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 168  : 	if (ftStatus != FT_OK) return false;

  0005e	85 c0		 test	 eax, eax
  00060	75 1e		 jne	 SHORT $LN6@Open

; 169  : 
; 170  : //	FT_SetUSBParameters(ftHandle, 8192, 8192);
; 171  : //	FT_SetBaudRate(ftHandle, 9600);
; 172  : 	
; 173  : 	FT_SetTimeouts(ftHandle,4000,1000);

  00062	68 e8 03 00 00	 push	 1000			; 000003e8H
  00067	68 a0 0f 00 00	 push	 4000			; 00000fa0H
  0006c	ff 37		 push	 DWORD PTR [edi]
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_SetTimeouts@12
  00074	5f		 pop	 edi

; 174  : 	isUSB_open = true;

  00075	c6 46 04 01	 mov	 BYTE PTR [esi+4], 1

; 175  : 	return true;

  00079	b0 01		 mov	 al, 1
  0007b	5e		 pop	 esi

; 176  : }

  0007c	5d		 pop	 ebp
  0007d	c2 04 00	 ret	 4
$LN6@Open:
  00080	5f		 pop	 edi

; 168  : 	if (ftStatus != FT_OK) return false;

  00081	32 c0		 xor	 al, al
  00083	5e		 pop	 esi

; 176  : }

  00084	5d		 pop	 ebp
  00085	c2 04 00	 ret	 4
?Open@CUSB@@QAE_NQAD@Z ENDP				; CUSB::Open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Beat\git_projekte\dtb\psi46test\usb.cpp
;	COMDAT ?Enum@CUSB@@QAE_NQADI@Z
_TEXT	SEGMENT
_name$ = 8						; size = 4
_pos$ = 12						; size = 4
?Enum@CUSB@@QAE_NQADI@Z PROC				; CUSB::Enum, COMDAT
; _this$ = ecx

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 73   : 	enumPos=pos;

  00003	8b 45 0c	 mov	 eax, DWORD PTR _pos$[ebp]
  00006	56		 push	 esi
  00007	8b f1		 mov	 esi, ecx
  00009	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 74   : 	if (enumPos >= enumCount) return false;

  0000c	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  0000f	73 24		 jae	 SHORT $LN5@Enum

; 75   : 	ftStatus = FT_ListDevices((PVOID)enumPos, name, FT_LIST_BY_INDEX);

  00011	68 00 00 00 40	 push	 1073741824		; 40000000H
  00016	ff 75 08	 push	 DWORD PTR _name$[ebp]
  00019	50		 push	 eax
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_ListDevices@12
  00020	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 76   : 	if (ftStatus != FT_OK)

  00023	85 c0		 test	 eax, eax
  00025	74 15		 je	 SHORT $LN3@Enum

; 77   : 	{
; 78   : 		enumCount = enumPos = 0;

  00027	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002e	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN5@Enum:

; 83   : }

  00035	32 c0		 xor	 al, al
  00037	5e		 pop	 esi
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
$LN3@Enum:

; 79   : 		return false;
; 80   : 	}
; 81   : 
; 82   : 	return true;

  0003c	b0 01		 mov	 al, 1
  0003e	5e		 pop	 esi

; 83   : }

  0003f	5d		 pop	 ebp
  00040	c2 08 00	 ret	 8
?Enum@CUSB@@QAE_NQADI@Z ENDP				; CUSB::Enum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Beat\git_projekte\dtb\psi46test\usb.cpp
;	COMDAT ?EnumNext@CUSB@@QAE_NQAD@Z
_TEXT	SEGMENT
_name$ = 8						; size = 4
?EnumNext@CUSB@@QAE_NQAD@Z PROC				; CUSB::EnumNext, COMDAT
; _this$ = ecx

; 58   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	8b f1		 mov	 esi, ecx

; 59   : 	if (enumPos >= enumCount) return false;

  00006	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  00009	3b 46 14	 cmp	 eax, DWORD PTR [esi+20]
  0000c	73 24		 jae	 SHORT $LN5@EnumNext

; 60   : 	ftStatus = FT_ListDevices((PVOID)enumPos, name, FT_LIST_BY_INDEX);

  0000e	68 00 00 00 40	 push	 1073741824		; 40000000H
  00013	ff 75 08	 push	 DWORD PTR _name$[ebp]
  00016	50		 push	 eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_ListDevices@12
  0001d	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 61   : 	if (ftStatus != FT_OK)

  00020	85 c0		 test	 eax, eax
  00022	74 15		 je	 SHORT $LN3@EnumNext

; 62   : 	{
; 63   : 		enumCount = enumPos = 0;

  00024	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002b	c7 46 14 00 00
	00 00		 mov	 DWORD PTR [esi+20], 0
$LN5@EnumNext:

; 69   : }

  00032	32 c0		 xor	 al, al
  00034	5e		 pop	 esi
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
$LN3@EnumNext:

; 64   : 		return false;
; 65   : 	}
; 66   : 
; 67   : 	enumPos++;

  00039	ff 46 10	 inc	 DWORD PTR [esi+16]

; 68   : 	return true;

  0003c	b0 01		 mov	 al, 1
  0003e	5e		 pop	 esi

; 69   : }

  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?EnumNext@CUSB@@QAE_NQAD@Z ENDP				; CUSB::EnumNext
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Beat\git_projekte\dtb\psi46test\usb.cpp
;	COMDAT ?EnumFirst@CUSB@@QAE_NAAI@Z
_TEXT	SEGMENT
_nDevices$ = 8						; size = 4
?EnumFirst@CUSB@@QAE_NAAI@Z PROC			; CUSB::EnumFirst, COMDAT
; _this$ = ecx

; 42   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b f1		 mov	 esi, ecx

; 43   : 	ftStatus = FT_ListDevices(&enumCount,

  00007	68 01 00 00 80	 push	 -2147483647		; 80000001H
  0000c	6a 00		 push	 0
  0000e	8d 7e 14	 lea	 edi, DWORD PTR [esi+20]
  00011	57		 push	 edi
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_ListDevices@12
  00018	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 44   : 		NULL,FT_LIST_NUMBER_ONLY|FT_OPEN_BY_SERIAL_NUMBER);
; 45   : 	if (ftStatus != FT_OK)

  0001b	85 c0		 test	 eax, eax
  0001d	8b 45 08	 mov	 eax, DWORD PTR _nDevices$[ebp]
  00020	74 1b		 je	 SHORT $LN2@EnumFirst

; 46   : 	{
; 47   : 		nDevices = enumCount = enumPos = 0;

  00022	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
  00028	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0
  0002f	5f		 pop	 edi
  00030	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 48   : 		return false;

  00036	32 c0		 xor	 al, al

; 54   : }

  00038	5e		 pop	 esi
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
$LN2@EnumFirst:

; 49   : 	}
; 50   : 
; 51   : 	nDevices = enumCount;

  0003d	8b 0f		 mov	 ecx, DWORD PTR [edi]
  0003f	89 08		 mov	 DWORD PTR [eax], ecx

; 52   : 	enumPos = 0;
; 53   : 	return true;

  00041	b0 01		 mov	 al, 1
  00043	5f		 pop	 edi
  00044	c7 46 10 00 00
	00 00		 mov	 DWORD PTR [esi+16], 0

; 54   : }

  0004b	5e		 pop	 esi
  0004c	5d		 pop	 ebp
  0004d	c2 04 00	 ret	 4
?EnumFirst@CUSB@@QAE_NAAI@Z ENDP			; CUSB::EnumFirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Beat\git_projekte\dtb\psi46test\usb.cpp
;	COMDAT ?GetErrorMsg@CUSB@@SAPBDH@Z
_TEXT	SEGMENT
_error$ = 8						; size = 4
?GetErrorMsg@CUSB@@SAPBDH@Z PROC			; CUSB::GetErrorMsg, COMDAT

; 14   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15   : 	switch (error)

  00003	8b 45 08	 mov	 eax, DWORD PTR _error$[ebp]
  00006	83 f8 12	 cmp	 eax, 18			; 00000012H
  00009	0f 87 8c 00 00
	00		 ja	 $LN2@GetErrorMs
  0000f	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN24@GetErrorMs[eax*4]
$LN4@GetErrorMs:

; 16   : 	{
; 17   :     case FT_OK:                          return "ok";

  00016	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_02MFDMBIJM@ok@

; 38   : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
$LN5@GetErrorMs:

; 18   :     case FT_INVALID_HANDLE:              return "invalid handle";

  0001d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0P@MNPFLEBL@invalid?5handle@

; 38   : }

  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
$LN6@GetErrorMs:

; 19   :     case FT_DEVICE_NOT_FOUND:            return "device not found";

  00024	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BB@IHDJLKMG@device?5not?5found@

; 38   : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
$LN7@GetErrorMs:

; 20   :     case FT_DEVICE_NOT_OPENED:           return "device not opened";

  0002b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@HFCLPILE@device?5not?5opened@

; 38   : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
$LN8@GetErrorMs:

; 21   :     case FT_IO_ERROR:                    return "io error";

  00032	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08GLNPIFBN@io?5error@

; 38   : }

  00037	5d		 pop	 ebp
  00038	c3		 ret	 0
$LN9@GetErrorMs:

; 22   :     case FT_INSUFFICIENT_RESOURCES:      return "insufficient resource";

  00039	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BG@JGELIADJ@insufficient?5resource@

; 38   : }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
$LN10@GetErrorMs:

; 23   :     case FT_INVALID_PARAMETER:           return "invalid parameter";

  00040	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@GMEMBNHN@invalid?5parameter@

; 38   : }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
$LN11@GetErrorMs:

; 24   :     case FT_INVALID_BAUD_RATE:           return "invalid baud rate";

  00047	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BC@JEMNCEK@invalid?5baud?5rate@

; 38   : }

  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
$LN12@GetErrorMs:

; 25   :     case FT_DEVICE_NOT_OPENED_FOR_ERASE: return "device not opened for erase";

  0004e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BM@FOIECFGC@device?5not?5opened?5for?5erase@

; 38   : }

  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
$LN13@GetErrorMs:

; 26   :     case FT_DEVICE_NOT_OPENED_FOR_WRITE: return "device not opened for write";

  00055	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BM@NAGBLIJI@device?5not?5opened?5for?5write@

; 38   : }

  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
$LN14@GetErrorMs:

; 27   :     case FT_FAILED_TO_WRITE_DEVICE:      return "failed to write device";

  0005c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BH@CBBLICLP@failed?5to?5write?5device@

; 38   : }

  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
$LN15@GetErrorMs:

; 28   :     case FT_EEPROM_READ_FAILED:          return "eeprom read failed";

  00063	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BD@HPOCEFDP@eeprom?5read?5failed@

; 38   : }

  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
$LN16@GetErrorMs:

; 29   :     case FT_EEPROM_WRITE_FAILED:         return "eeprom write failed";

  0006a	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BE@KJGDCNBK@eeprom?5write?5failed@

; 38   : }

  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
$LN17@GetErrorMs:

; 30   :     case FT_EEPROM_ERASE_FAILED:         return "eeprom erase failed";

  00071	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BE@CFCHMELH@eeprom?5erase?5failed@

; 38   : }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
$LN18@GetErrorMs:

; 31   : 	case FT_EEPROM_NOT_PRESENT:          return "eeprom not present";

  00078	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BD@JKEPJBHF@eeprom?5not?5present@

; 38   : }

  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
$LN19@GetErrorMs:

; 32   : 	case FT_EEPROM_NOT_PROGRAMMED:       return "eeprom not programmed";

  0007f	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BG@JMCJFOE@eeprom?5not?5programmed@

; 38   : }

  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
$LN20@GetErrorMs:

; 33   : 	case FT_INVALID_ARGS:                return "invalid args";

  00086	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0N@LBHEEELJ@invalid?5args@

; 38   : }

  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN21@GetErrorMs:

; 34   : 	case FT_NOT_SUPPORTED:               return "not supported";

  0008d	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0O@NHEDABJP@not?5supported@

; 38   : }

  00092	5d		 pop	 ebp
  00093	c3		 ret	 0
$LN22@GetErrorMs:

; 35   : 	case FT_OTHER_ERROR:                 return "other error";

  00094	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0M@CBIEBGLO@other?5error@

; 38   : }

  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
$LN2@GetErrorMs:

; 36   : 	}
; 37   : 	return "unknown error";

  0009b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0O@BFJCFAAK@unknown?5error@

; 38   : }

  000a0	5d		 pop	 ebp
  000a1	c3		 ret	 0
  000a2	66 90		 npad	 2
$LN24@GetErrorMs:
  000a4	00 00 00 00	 DD	 $LN4@GetErrorMs
  000a8	00 00 00 00	 DD	 $LN5@GetErrorMs
  000ac	00 00 00 00	 DD	 $LN6@GetErrorMs
  000b0	00 00 00 00	 DD	 $LN7@GetErrorMs
  000b4	00 00 00 00	 DD	 $LN8@GetErrorMs
  000b8	00 00 00 00	 DD	 $LN9@GetErrorMs
  000bc	00 00 00 00	 DD	 $LN10@GetErrorMs
  000c0	00 00 00 00	 DD	 $LN11@GetErrorMs
  000c4	00 00 00 00	 DD	 $LN12@GetErrorMs
  000c8	00 00 00 00	 DD	 $LN13@GetErrorMs
  000cc	00 00 00 00	 DD	 $LN14@GetErrorMs
  000d0	00 00 00 00	 DD	 $LN15@GetErrorMs
  000d4	00 00 00 00	 DD	 $LN16@GetErrorMs
  000d8	00 00 00 00	 DD	 $LN17@GetErrorMs
  000dc	00 00 00 00	 DD	 $LN18@GetErrorMs
  000e0	00 00 00 00	 DD	 $LN19@GetErrorMs
  000e4	00 00 00 00	 DD	 $LN20@GetErrorMs
  000e8	00 00 00 00	 DD	 $LN21@GetErrorMs
  000ec	00 00 00 00	 DD	 $LN22@GetErrorMs
?GetErrorMsg@CUSB@@SAPBDH@Z ENDP			; CUSB::GetErrorMsg
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Beat\git_projekte\dtb\psi46test\usb.cpp
;	COMDAT ?FillBuffer@CUSB@@AAE_NK@Z
_TEXT	SEGMENT
_bytesAvailable$ = -4					; size = 4
_minBytesToRead$ = 8					; size = 4
?FillBuffer@CUSB@@AAE_NK@Z PROC				; CUSB::FillBuffer, COMDAT
; _this$ = ecx

; 218  : { PROFILING

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	8b f1		 mov	 esi, ecx
  00007	57		 push	 edi

; 219  : 	if (!isUSB_open) return false;

  00008	80 7e 04 00	 cmp	 BYTE PTR [esi+4], 0
  0000c	74 61		 je	 SHORT $LN8@FillBuffer

; 220  : 
; 221  : 	DWORD bytesAvailable, bytesToRead;
; 222  : 
; 223  : 	ftStatus = FT_GetQueueStatus(ftHandle, &bytesAvailable);

  0000e	8d 45 fc	 lea	 eax, DWORD PTR _bytesAvailable$[ebp]
  00011	50		 push	 eax
  00012	ff 76 08	 push	 DWORD PTR [esi+8]
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_GetQueueStatus@8
  0001b	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 224  : 	if (ftStatus != FT_OK) return false;

  0001e	85 c0		 test	 eax, eax
  00020	75 4d		 jne	 SHORT $LN8@FillBuffer

; 225  : 
; 226  : 	if (m_posR<m_sizeR) return false;

  00022	8b 86 1c 04 00
	00		 mov	 eax, DWORD PTR [esi+1052]
  00028	8d be 20 04 00
	00		 lea	 edi, DWORD PTR [esi+1056]
  0002e	3b 07		 cmp	 eax, DWORD PTR [edi]
  00030	72 3d		 jb	 SHORT $LN8@FillBuffer

; 227  : 
; 228  : 	bytesToRead = (bytesAvailable>minBytesToRead)? bytesAvailable : minBytesToRead;

  00032	8b 4d 08	 mov	 ecx, DWORD PTR _minBytesToRead$[ebp]

; 229  : 	if (bytesToRead>USBREADBUFFERSIZE) bytesToRead = USBREADBUFFERSIZE;

  00035	b8 00 10 00 00	 mov	 eax, 4096		; 00001000H
  0003a	39 4d fc	 cmp	 DWORD PTR _bytesAvailable$[ebp], ecx

; 230  : 
; 231  : 	ftStatus = FT_Read(ftHandle, m_bufferR, bytesToRead, &m_sizeR);

  0003d	57		 push	 edi
  0003e	0f 47 4d fc	 cmova	 ecx, DWORD PTR _bytesAvailable$[ebp]
  00042	3b c8		 cmp	 ecx, eax
  00044	0f 47 c8	 cmova	 ecx, eax
  00047	8d 86 24 04 00
	00		 lea	 eax, DWORD PTR [esi+1060]
  0004d	51		 push	 ecx
  0004e	50		 push	 eax
  0004f	ff 76 08	 push	 DWORD PTR [esi+8]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FT_Read@16
  00058	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 232  : 	m_posR = 0;

  0005b	c7 86 1c 04 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+1052], 0

; 233  : 	if (ftStatus != FT_OK)

  00065	85 c0		 test	 eax, eax
  00067	74 10		 je	 SHORT $LN6@FillBuffer

; 234  : 	{
; 235  : 		m_sizeR = 0;

  00069	c7 07 00 00 00
	00		 mov	 DWORD PTR [edi], 0
$LN8@FillBuffer:
  0006f	5f		 pop	 edi

; 239  : }

  00070	32 c0		 xor	 al, al
  00072	5e		 pop	 esi
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
$LN6@FillBuffer:
  00079	5f		 pop	 edi

; 236  : 		return false;
; 237  : 	}
; 238  : 	return true;

  0007a	b0 01		 mov	 al, 1

; 239  : }

  0007c	5e		 pop	 esi
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
?FillBuffer@CUSB@@AAE_NK@Z ENDP				; CUSB::FillBuffer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File C:\Users\Beat\git_projekte\dtb\psi46test\rpc_error.h
;	COMDAT ??0CRpcError@@QAE@W4errorId@0@@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
??0CRpcError@@QAE@W4errorId@0@@Z PROC			; CRpcError::CRpcError, COMDAT
; _this$ = ecx

; 33   : 	CRpcError(errorId e) : error(e) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR _e$[ebp]
  00006	89 01		 mov	 DWORD PTR [ecx], eax
  00008	8b c1		 mov	 eax, ecx
  0000a	5d		 pop	 ebp
  0000b	c2 04 00	 ret	 4
??0CRpcError@@QAE@W4errorId@0@@Z ENDP			; CRpcError::CRpcError
_TEXT	ENDS
END
